function [doublets, circulation, lift] = WingLift(points, stream, ...
    density, wake, theta, out)
% Given a list of points that define a 2-d cross section of a wing,
% calculates an estimate of the doublet strengths of each linear section 
% of the wing, the circulation arround the wing, and the lift generated per
% meter of wing. All units are SI - so meters, seconds, kilograms, and
% Netwons.
%
% WingLift(points, stream, density, wake, theta, out) uses:
%   
%   points: An nx2 matrix of points that define an outline of the wing. The
%           first and last point should be the same.
%   stream: A 2x1 free stream vector, usually the negative direction of
%           movement.
%   density:The density of air used in the lift calculations. If omitted,
%           defaults to the density at sea level at 15C, 1.225 kg/m^3.
%   wake:   The wake point used in calculations of the wing. If omitted, 
%           uses the last row in points as the wake instead.
%   theta:  A scalar in [0,1] that determines what convex combination of
%           the endpoints to use as the collection point when finding the
%           influence vectors. If omitted, defaults to 0.5.
%   out:    A boolean that determines whether to print additional
%           information. If omitted, defaults to false.
%
% [doublets, circulation, lift] = WingLift(...)
%
%   doublets:       An column vector of doublet strengths for the linear
%                   sections of the wing and the wake.
%   circulation:    An estimate of the total circulation arround the wing.
%   lift:           An estimate of the lift force per square meter
%                   generated by the wing.

if nargin < 6
    out = false;
end

if nargin < 5
    theta = 0.5;
end

if nargin < 4
    wake = points(end, :);
    points = points(1:end-1,:);
end

if nargin < 3
    density = 1.225;
end


% Computes the vectors for each panel from the vector of points.
panels = points(2:end, :) - points(1:end - 1, :);
panels(end+1, :) = points(end, :) - wake;

if out
    fprintf("Panels: \n")
    panels
end

% Computes the inward-facing normal vectors for each panel.
prenormals = [-panels(:, 2) , panels(:, 1)];
normals = prenormals./vecnorm(prenormals, 2, 2);

if out
    fprintf("Normals: \n")
    normals
end

% Computes angles to the z axis for each panel.
thetas = -sign(normals(:, 1)).*acos(-normals(:, 2));

if out
    fprintf("thetas: \n")
    thetas
end

% Computes d values for each panel.
ds = vecnorm(panels, 2, 2) * 0.5;

if out
    fprintf("ds: \n")
    ds
end

% Computes the collection points and midpoints for each line. Also we need
% the wake point again.
points(end+1, :) = wake;
midpoints = 0.5 * points(2:end, :) + 0.5 * points(1:end - 1, :);
collect = theta * points(2:end, :) + (1-theta) * points(1:end - 1, :);

endpoints = points';

if out
    fprintf("Midpoints and Collection Points: \n")
    midpoints
    collect
end

n = size(normals, 1);

% Computes rotation matrices.
rotations = zeros(2*n, 2);
for i=1:n
    rotations(2*i - 1, 1) = cos(thetas(i));
    rotations(2*i, 1) = sin(thetas(i));
    rotations(2*i - 1, 2) = -sin(thetas(i));
    rotations(2*i, 2) = cos(thetas(i));
end

if out
    fprintf("Rotations: \n")
    rotations
end

% Translates and rotates each collection point with respect to each angle 
% to form a nx2n matrix of collection points.
collect = collect';
transcollect = (repmat(collect(:), 1, n)' - repmat(midpoints, 1, n));

transend = (repmat(endpoints(:), 1, n)' - repmat(midpoints, 1, n+1));

for i=1:n
    for j=1:2:2*n
        transcollect(i,j:j+1) = transcollect(i,j:j+1) * ...
                                        rotations(2*i-1:2*i,:)';
    end
end

for i=1:n
    for j=1:2:2*n+1
        transend(i,j:j+1) = transend(i,j:j+1) * ...
                        rotations(2*i-1:2*i,:)';
    end
end

if out
    fprintf("Transformed collection points: \n")
    transcollect
    
    % This is for debugging purposes only right now.
    plot(points(:, 1), points(:, 2))
    hold on
    plot(collect(1, :), collect(2, :), '.', MarkerSize=20)
    temp = reshape(transcollect(2, :), 2, [])';
    plot(temp(:, 1), temp(:, 2), '.', MarkerSize=20)
    temp = reshape(transend(2, :), 2, [])';
    plot(temp(:, 1), temp(:, 2))
    hold off
end

% Computes the A matrix and transforms the coordinates back.
A = zeros(n-1:n);
for i=1:n-1
    for j=1:n
        if i == j
            phi = rotations(2*i-1:2*i,:) \ [0; -1/(pi*ds(i))];
        else
            x = transcollect(j, 2*i-1);
            z = transcollect(j, 2*i);
            d = ds(j);
            transphi = 1/(2*pi) * [z/norm([x+d,z])^2 - z/norm([x-d,z])^2; ...
                            (x-d)/norm([x-d,z])^2 - (x+d)/norm([x+d,z])^2];
            phi = (rotations(2*j-1:2*j,:) \ transphi);
        end
        A(i, j) = phi(1)*normals(i, 1) + phi(2)*normals(i, 2);
    end
end


if out
    fprintf("A matrix: \n")
    A
end

% Enforces the Kutta condition.
A(:,1) = A(:,1) + A(:,end);
A(:,end-1) = A(:,end-1) - A(:,end);
A(:,end) = [];

if out
    fprintf("A matrix after Kutta Condtion: \n")
    A
end

b = zeros(n-1, 1);

for i=1:n-1
    b(i) = normals(i,1)*stream(1)+normals(i,2)*stream(2);
end

if out
    fprintf("b: \n")
    b
end

doublets = A\b; 
circulation = -doublets(end);
lift = density * circulation * norm(stream);


